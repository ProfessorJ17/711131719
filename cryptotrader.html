<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Real Crypto Trader Simulator</title>
  <style>
    body {
      font-family: 'futuristic', sans-serif;
      background: url('data:image/svg+xml,%3Csvg width="50" height="50" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg"%3E%3Cdefs%3E%3Cpattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse"%3E%3Cpath d="M0 0 L50 0 L50 50 L0 50 Z" fill="rgba(0,0,0,0.2)"/%3E%3Cpath d="M0 0 H50 V1 H0 Z M0 0 V50 H1 Z" stroke="%2300f0ff" stroke-width="0.5"/%3E%3C/pattern%3E%3C/defs%3E%3Crect width="100%25" height="100%25" fill="url(%23grid)"/%3E%3C/svg%3E');
      color: #00f0ff;
      text-align: center;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }

    @font-face {
      font-family: 'futuristic';
      src: url('https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap');
      font-display: swap;
    }


    h1 {
      color: #ff77ff;
      text-shadow: 0 0 10px #ff77ff;
      margin-top: 20px;
    }

    h2 {
      color: #00ffbb;
      text-shadow: 0 0 8px #00ffbb;
    }

    table {
      width: 95%;
      margin: 20px auto;
      border-collapse: separate;
      border-spacing: 0;
      background: rgba(51, 51, 51, 0.8);
      backdrop-filter: blur(5px);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.3);
    }

    th,
    td {
      padding: 12px 10px;
      border: none;
      text-align: left;
      vertical-align: middle;
      word-wrap: break-word;
      border-bottom: 1px solid rgba(102, 102, 102, 0.5);
      border-right: 1px solid rgba(102, 102, 102, 0.5);
    }

    th {
      background: rgba(68, 68, 68, 0.9);
      color: #ffcc00;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      text-shadow: 0 0 5px #ffcc00;
    }

    th:first-child {
      border-radius: 12px 0 0 0;
    }

    th:last-child {
      border-radius: 0 12px 0 0;
    }

    tr:last-child td {
      border-bottom: none;
    }

    tr td:last-child {
      border-right: none;
    }

    th:nth-child(1),
    td:nth-child(1) {
      width: 10%;
    }

    th:nth-child(2),
    td:nth-child(2) {
      width: 10%;
    }

    th:nth-child(3),
    td:nth-child(3) {
      width: 10%;
    }

    th:nth-child(4),
    td:nth-child(4) {
      width: 15%;
    }

    th:nth-child(5),
    td:nth-child(5) {
      width: 20%;
    }

    th:nth-child(6),
    td:nth-child(6) {
      width: 25%;
    }

    th:nth-child(7),
    td:nth-child(7) {
      width: 10%;
    }

    th:nth-child(8),
    td:nth-child(8) {
      width: 10%;
    }

    .price-up {
      color: #00ff00;
      text-shadow: 0 0 5px #00ff00;
    }

    .price-down {
      color: #ff0000;
      text-shadow: 0 0 5px #ff0000;
    }

    .buy-signal {
      color: #00ff00;
      font-weight: bold;
      text-shadow: 0 0 7px #00ff00;
    }

    .sell-signal {
      color: #ff0000;
      font-weight: bold;
      text-shadow: 0 0 7px #ff0000;
    }

    button,
    .tab-button,
    .trade-button,
    .reset-section button,
    .balance-button {
      padding: 10px 20px;
      background: #00f0ff;
      color: #000;
      border: none;
      cursor: pointer;
      margin: 5px;
      border-radius: 8px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease;
      box-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
    }

    button:hover,
    .tab-button:hover,
    .trade-button:hover,
    .reset-section button:hover,
    .balance-button:hover {
      background-color: #ff77ff;
      color: #000;
      box-shadow: 0 0 15px #ff77ff;
      transform: scale(1.05);
    }

    #loginArea {
      margin: 50px auto;
      width: 320px;
      padding: 30px;
      background: rgba(51, 51, 51, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      box-shadow: 0 0 30px rgba(0, 240, 255, 0.5);
    }

    #loginArea input {
      margin: 15px 0;
      padding: 12px;
      width: calc(100% - 24px);
      box-sizing: border-box;
      background: #444;
      color: #fff;
      border: 1px solid #666;
      border-radius: 6px;
    }

    #loginArea button {
      width: 100%;
      margin-top: 20px;
    }

    .loading {
      color: #ffcc00;
      font-style: italic;
      text-shadow: 0 0 5px #ffcc00;
    }

    .signal-details {
      font-size: 0.9em;
      color: #aaa;
      margin-top: 8px;
    }

    .indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
    }

    .indicator-strong {
      background-color: #00ff00;
      box-shadow: 0 0 10px #00ff00;
    }

    .indicator-weak {
      background-color: #ff0000;
      box-shadow: 0 0 10px #ff0000;
    }

    .technical-details {
      font-size: 0.9em;
      padding: 8px;
      background: rgba(42, 42, 42, 0.7);
      border-radius: 6px;
      margin-top: 8px;
      border: 1px solid #555;
    }

    .status-message {
      color: #00f0ff;
      margin: 15px;
      font-style: italic;
      text-shadow: 0 0 5px #00f0ff;
    }

    .trade-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .trade-button {
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.95em;
      box-shadow: 0 0 8px rgba(0, 240, 255, 0.4);
    }

    .buy-button {
      background: #00ff00;
      color: #000;
      box-shadow: 0 0 10px #00ff00;
    }

    .sell-button {
      background: #ff0000;
      color: #fff;
      box-shadow: 0 0 10px #ff0000;
    }

    .portfolio-section {
      width: 95%;
      margin: 20px auto;
      background: rgba(51, 51, 51, 0.8);
      backdrop-filter: blur(5px);
      padding: 25px;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.3);
    }

    .trade-modal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(68, 68, 68, 0.95);
      backdrop-filter: blur(15px);
      padding: 30px;
      border-radius: 15px;
      z-index: 1000;
      width: 340px;
      box-shadow: 0 0 40px rgba(0, 240, 255, 0.6);
      border: 1px solid #777;
    }

    .modal-backdrop {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999;
    }

    .trade-modal input {
      width: calc(100% - 24px);
      padding: 12px;
      margin: 15px 0;
      background: #333;
      border: 1px solid #555;
      color: white;
      border-radius: 6px;
    }

    .trade-modal button {
      margin: 8px;
      padding: 10px 20px;
    }

    .portfolio-table {
      width: 100%;
      margin-top: 25px;
    }

    .timestamp {
      font-size: 0.85em;
      color: #bbb;
    }

    .tabs {
      display: flex;
      gap: 15px;
      margin: 30px auto;
      width: 95%;
      justify-content: center;
    }

    .tab-button {
      padding: 12px 25px;
      background: #444;
      color: #fff;
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(100, 100, 100, 0.4);
    }

    .tab-button.active {
      background: #ffcc00;
      color: #000;
      box-shadow: 0 0 15px #ffcc00;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .reset-section {
      background: rgba(68, 68, 68, 0.9);
      padding: 25px;
      margin-bottom: 30px;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.3);
    }

    .reset-section h3 {
      color: #ff77ff;
      text-shadow: 0 0 8px #ff77ff;
      margin-top: 0;
    }

    .reset-section p {
      color: #ddd;
    }

    .reset-section button {
      margin: 10px;
      padding: 12px 25px;
      border-radius: 8px;
      font-weight: bold;
      box-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
    }

    #gameTimer {
      font-size: 1.5em;
      margin-top: 20px;
      color: #ffcc00;
      text-shadow: 0 0 8px #ffcc00;
    }

    #winMessage,
    #loseMessage {
      display: none;
      font-size: 2em;
      color: #00ff00;
      text-shadow: 0 0 10px #00ff00;
      margin-top: 20px;
    }

    #loseMessage {
      color: #ff0000;
      text-shadow: 0 0 10px #ff0000;
    }

    .balance-selection {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 20px;
    }

    .balance-button {
      padding: 15px 30px;
      font-size: 1.1em;
    }

    .login-options {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }

    .login-options button {
      padding: 12px 25px;
    }

    #loginForm,
    #newGameForm {
      display: none;
    }

    #newGameForm.active,
    #loginForm.active {
      display: block;
    }

    #realTime {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #00f0ff;
      font-size: 1em;
      text-shadow: 0 0 5px #00f0ff;
    }

    #instructionsModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(68, 68, 68, 0.95);
      backdrop-filter: blur(15px);
      padding: 30px;
      border-radius: 15px;
      z-index: 1000;
      width: 60%;
      max-height: 80%;
      overflow-y: auto;
      box-shadow: 0 0 40px rgba(0, 240, 255, 0.6);
      border: 1px solid #777;
    }

    #instructionsModal h2 {
      color: #00ffbb;
      text-shadow: 0 0 8px #00ffbb;
      margin-bottom: 20px;
    }

    #instructionsModal p,
    #instructionsModal li {
      color: #ddd;
      font-size: 1em;
      line-height: 1.6;
    }

    #instructionsModal ul {
      margin-left: 20px;
    }

    #instructionsModal button {
      margin-top: 20px;
      padding: 10px 20px;
    }

    /* Custom Scrollbar */
    #instructionsModal::-webkit-scrollbar {
      width: 8px;
    }

    #instructionsModal::-webkit-scrollbar-track {
      background: #333;
      border-radius: 4px;
    }

    #instructionsModal::-webkit-scrollbar-thumb {
      background: #00f0ff;
      border-radius: 4px;
    }

    #instructionsModal::-webkit-scrollbar-thumb:hover {
      background: #ff77ff;
    }

    .tab-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .tab-buttons {
      display: flex;
      gap: 15px;
      margin: 30px auto;
      width: 95%;
      justify-content: center;
    }
  </style>
</head>

<body>
  <div id="realTime">Loading Time...</div>
  <h1>Real Crypto Trader Simulator</h1>

  <div id="loginArea">
    <div class="login-options">
      <button onclick="showLoginForm()">Login</button>
      <button onclick="showNewGameForm()">Start New Game</button>
      <button onclick="showInstructionsModal()">Instructions</button>
    </div>

    <div id="loginForm">
      <h2>Login</h2>
      <input type="text" id="loginUsernameInput" placeholder="Enter username to login">
      <button onclick="loginUser()">Login</button>
    </div>

    <div id="newGameForm" class="active">
      <h2>Start New Game</h2>
      <input type="text" id="usernameInput" placeholder="Enter username">
      <div class="balance-selection">
        <button class="balance-button" onclick="startNewGame(100, 96.64)">$100</button>
        <button class="balance-button" onclick="startNewGame(1000, 72.48)">$1,000</button>
        <button class="balance-button" onclick="startNewGame(5000, 55.62)">$5,000</button>
        <button class="balance-button" onclick="startNewGame(10000, 48.33)">$10,000</button>
      </div>
      <button id="millionDollarResetLogin" style="display:none;" onclick="startNewGame(1000000, 40)">$1,000,000
        (Unlocked)</button>
    </div>
  </div>

  <div id="mainContent" style="display: none;">
    <div id="userBalance">Balance: $1000</div>
    <div id="gameTimer">Time Remaining: Loading...</div>
    <div id="winMessage">Congratulations! You reached $1,000,000!</div>
    <div id="loseMessage">Time's up! You did not reach $1,000,000 in time.</div>

    <div class="tab-container">
      <div class="tab-buttons">
        <button class="tab-button active" onclick="showTab('market')">Market</button>
        <button class="tab-button" onclick="showTab('portfolio')">Portfolio</button>
        <button onclick="showInstructionsModal()">Instructions</button>
      </div>
    </div>

    <div id="marketTab" class="tab-content active">
      <h2>Cryptocurrencies</h2>
      <button onclick="fetchCryptoData()">Load Crypto</button>
      <div id="statusMessage" class="status-message"></div>
      <table id="cryptoTable">
        <thead>
          <tr>
            <th>Name</th>
            <th>Price (USD)</th>
            <th>Change (%)</th>
            <th>Trading Signal</th>
            <th>Gann Trend</th>
            <th>Fibonacci Levels</th>
            <th>Market Cap</th>
            <th>Trade</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div id="portfolioTab" class="tab-content">
      <h2>Your Portfolio</h2>
      <table id="portfolioTable" class="portfolio-table">
        <thead>
          <tr>
            <th>Crypto</th>
            <th>Amount</th>
            <th>Purchase Price</th>
            <th>Current Price</th>
            <th>Value</th>
            <th>Profit/Loss</th>
            <th>Purchase Time</th>
            <th>Character Creation Time</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="reset-section">
        <h3>Reset Game</h3>
        <p>Choose a starting balance to reset your game. All progress will be lost.</p>
        <div class="balance-selection">
          <button class="balance-button" onclick="resetGame(1000, 72.48)">$1,000</button>
          <button class="balance-button" onclick="resetGame(5000, 55.62)">$5,000</button>
          <button class="balance-button" onclick="resetGame(10000, 48.33)">$10,000</button>
          <button id="millionDollarReset" style="display:none;" class="balance-button"
            onclick="resetGame(1000000, 40)">$1,000,000</button>
        </div>
      </div>
    </div>
  </div>

  <div id="tradeModal" class="trade-modal">
    <h3>Trade Cryptocurrency</h3>
    <p id="modalCryptoName"></p>
    <p id="modalPrice"></p>
    <input type="number" id="tradeAmount" placeholder="Amount in USD">
    <p id="estimatedCoins"></p>
    <button onclick="executeTrade()">Confirm</button>
    <button onclick="closeTradeModal()">Cancel</button>
  </div>
  <div id="modalBackdrop" class="modal-backdrop" onclick="closeTradeModal()"></div>

  <div id="instructionsModal" class="trade-modal">
    <h2>Trading Instructions</h2>
    <p><b>Objective:</b> Buy at predefined price levels and sell if the price drops by 5% from the purchase price.</p>
    <p><b>Buy Levels:</b></p>
    <ul>
      <li><b>"Strong Buy":</b> 3, 30, 300, or 3000 (depending on the asset's price scale).</li>
      <li><b>"Regular Buy":</b> 2, 20, 200, or 2000 (depending on the asset's price scale).</li>
    </ul>
    <p><b>Sell Condition:</b> Sell if the price drops by 5% from your purchase price.[MAX HALF PER WEEK!] </p>
    <p><b>Frequency:</b> Check prices daily.</p>
    <p><b>Cooldown Period:</b> Only buy or sell exactly 1 week (7 days) after your last trade (buy or sell) to allow for
      learning and analysis.</p>
    <button onclick="closeInstructionsModal()">Close</button>
  </div>

  <script>
    let userData = {
      username: null,
      balance: 1000,
      portfolio: {},
      transactions: [],
      millionDollarModeUnlocked: false,
      gameEndTime: null,
      characterCreationTime: null
    };

    let gameTimerInterval;
    let timeLeft;
    let gameEndTime;

    const CACHE_DURATION = 30 * 60 * 1000;
    const BATCH_SIZE = 3;
    const API_DELAY = 15000;
    let priceCache = {};
    let historicalCache = {};
    let lastApiCallTime = 0;

    function showTab(tabName) {
      document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));

      document.getElementById(tabName + 'Tab').classList.add('active');
      document.querySelector(`.tab-button[onclick="showTab('${tabName}')"]`).classList.add('active');

      if (tabName === 'portfolio') {
        updatePortfolioDisplay();
      }
    }

    let currentTradeInfo = null;

    function showTradeModal(crypto, price, isBuy) {
      currentTradeInfo = {
        crypto,
        price,
        isBuy
      };
      document.getElementById('modalCryptoName').textContent = `${isBuy ? 'Buy' : 'Sell'} ${crypto}`;
      document.getElementById('modalPrice').textContent = `Current Price: $${price}`;
      document.getElementById('tradeModal').style.display = 'block';
      document.getElementById('modalBackdrop').style.display = 'block';

      document.getElementById('tradeAmount').addEventListener('input', updateEstimatedCoins);
    }

    function updateEstimatedCoins() {
      const usdAmount = parseFloat(document.getElementById('tradeAmount').value) || 0;
      const estimatedCoins = (usdAmount / currentTradeInfo.price).toFixed(8);
      document.getElementById('estimatedCoins').textContent =
        `Estimated coins: ${estimatedCoins} ${currentTradeInfo.crypto}`;
    }

    function closeTradeModal() {
      document.getElementById('tradeModal').style.display = 'none';
      document.getElementById('modalBackdrop').style.display = 'none';
      document.getElementById('tradeAmount').value = '';
      document.getElementById('estimatedCoins').textContent = '';
      currentTradeInfo = null;
    }

    function executeTrade() {
      if (!currentTradeInfo) return;

      const amount = parseFloat(document.getElementById('tradeAmount').value);
      if (isNaN(amount) || amount <= 0) {
        alert('Please enter a valid amount');
        return;
      }

      const timestamp = new Date().toISOString();

      if (currentTradeInfo.isBuy) {
        if (amount > userData.balance) {
          alert('Insufficient funds');
          return;
        }

        const coins = amount / currentTradeInfo.price;
        userData.balance -= amount;

        const transaction = {
          type: 'buy',
          crypto: currentTradeInfo.crypto,
          amount: coins,
          price: currentTradeInfo.price,
          usdAmount: amount,
          timestamp: timestamp
        };

        userData.transactions.push(transaction);

        if (!userData.portfolio[currentTradeInfo.crypto]) {
          userData.portfolio[currentTradeInfo.crypto] = [];
        }

        userData.portfolio[currentTradeInfo.crypto].push({
          amount: coins,
          purchasePrice: currentTradeInfo.price,
          purchaseTime: timestamp,
          totalInvested: amount
        });

      } else {
        const portfolio = userData.portfolio[currentTradeInfo.crypto];
        if (!portfolio || !portfolio.length) {
          alert('No crypto balance to sell');
          return;
        }

        let remainingAmountToSell = amount;
        let totalValue = 0;

        while (remainingAmountToSell > 0 && portfolio.length > 0) {
          const position = portfolio[0];
          if (position.amount <= remainingAmountToSell) {
            remainingAmountToSell -= position.amount;
            totalValue += position.amount * currentTradeInfo.price;
            portfolio.shift();
          } else {
            position.amount -= remainingAmountToSell;
            position.totalInvested = position.amount * position.purchasePrice;
            totalValue += remainingAmountToSell * currentTradeInfo.price;
            remainingAmountToSell = 0;
          }
        }

        if (remainingAmountToSell > 0) {
          alert('Insufficient crypto balance');
          return;
        }

        userData.balance += totalValue;

        userData.transactions.push({
          type: 'sell',
          crypto: currentTradeInfo.crypto,
          amount: amount,
          price: currentTradeInfo.price,
          usdAmount: totalValue,
          timestamp: timestamp
        });

        if (portfolio.length === 0) {
          delete userData.portfolio[currentTradeInfo.crypto];
        }
      }

      saveUserData();
      updateBalanceDisplay();
      updatePortfolioDisplay();
      closeTradeModal();
      alert(`Successfully ${currentTradeInfo.isBuy ? 'bought' : 'sold'} ${currentTradeInfo.crypto}`);
    }

    function updatePortfolioDisplay() {
      const table = document.querySelector("#portfolioTable tbody");
      table.innerHTML = '';

      for (const [crypto, positions] of Object.entries(userData.portfolio)) {
        if (!Array.isArray(positions)) {
          console.error(`Portfolio data for ${crypto} is not an array:`, positions);
          continue;
        }
        const currentPrice = priceCache?.data?.[crypto.toLowerCase()]?.usd || 0;

        positions.forEach((position) => {
          const currentValue = position.amount * currentPrice;
          const profitLoss = currentValue - position.totalInvested;
          const profitLossPercent = (profitLoss / position.totalInvested * 100).toFixed(2);

          const purchaseDate = new Date(position.purchaseTime);
          const formattedPurchaseDate = purchaseDate.toLocaleString();

          const creationDate = new Date(userData.characterCreationTime);
          const formattedCreationDate = creationDate.toLocaleString();

          const row = document.createElement('tr');
          row.innerHTML = `
                        <td>${crypto}</td>
                        <td>${position.amount.toFixed(8)}</td>
                        <td>$${position.purchasePrice.toFixed(2)}</td>
                        <td>$${currentPrice.toFixed(2)}</td>
                        <td>$${currentValue.toFixed(2)}</td>
                        <td class="${profitLoss >= 0 ? 'price-up' : 'price-down'}">
                            $${profitLoss.toFixed(2)} (${profitLossPercent}%)
                        </td>
                        <td class="timestamp">${formattedPurchaseDate}</td>
                        <td class="timestamp">${formattedCreationDate}</td>
                        <td>
                            <button class="trade-button sell-button"
                                    onclick="showTradeModal('${crypto}', ${currentPrice}, false)">
                                Sell
                            </button>
                        </td>
                    `;
          table.appendChild(row);
        });
      }
    }

    function resetGame(startingBalance, weeksToMillion) {
      if (confirm(
          `Are you sure you want to reset the game with $${startingBalance.toLocaleString()} starting balance? This will erase all your current progress.`
        )) {
        userData = {
          username: userData.username,
          balance: startingBalance,
          portfolio: {},
          transactions: [],
          millionDollarModeUnlocked: userData.millionDollarModeUnlocked || startingBalance === 1000000,
          gameEndTime: null,
          characterCreationTime: Date.now() // Reset character creation time on game reset
        };
        saveUserData();
        updateBalanceDisplay();
        updatePortfolioDisplay();
        startTimer(weeksToMillion);
        document.getElementById('winMessage').style.display = 'none';
        document.getElementById('loseMessage').style.display = 'none';
        alert(`Game reset! Starting balance set to $${startingBalance.toLocaleString()}`);
      }
    }

    function startTimer(weeks) {
      if (gameTimerInterval) {
        clearInterval(gameTimerInterval);
      }

      const seconds = weeks * 7 * 24 * 60 * 60;
      timeLeft = seconds;
      gameEndTime = Date.now() + timeLeft * 1000;
      userData.gameEndTime = gameEndTime;
      saveUserData();

      startTimerDisplay();
    }

    function startTimerDisplay() {
      if (gameTimerInterval) {
        clearInterval(gameTimerInterval);
      }
      gameTimerInterval = setInterval(updateTimerDisplay, 1000);
      updateTimerDisplay();
    }

    function updateTimerDisplay() {
      if (timeLeft <= 0) {
        clearInterval(gameTimerInterval);
        timeLeft = 0;
        document.getElementById('gameTimer').innerText = "Time's Up!";
        if (userData.balance < 1000000) {
          document.getElementById('loseMessage').style.display = 'block';
        }
        return;
      }

      const weeks = Math.floor(timeLeft / (7 * 24 * 60 * 60));
      const days = Math.floor((timeLeft % (7 * 24 * 60 * 60)) / (24 * 60 * 60));
      const hours = Math.floor((timeLeft % (24 * 60 * 60)) / (60 * 60));
      const minutes = Math.floor((timeLeft % (60 * 60)) / 60);
      const seconds = Math.floor(timeLeft % 60);

      document.getElementById('gameTimer').innerText =
        `Time Remaining: ${weeks}w ${days}d ${hours}h ${minutes}m ${seconds}s`;
      timeLeft--;

      if (userData.balance >= 1000000) {
        clearInterval(gameTimerInterval);
        document.getElementById('gameTimer').innerText = "You Win!";
        document.getElementById('winMessage').style.display = 'block';
        if (!userData.millionDollarModeUnlocked) {
          userData.millionDollarModeUnlocked = true;
          document.getElementById('millionDollarResetLogin').style.display = 'inline-block';
          document.getElementById('millionDollarReset').style.display = 'inline-block';
          saveUserData();
        }
      }
    }

    function saveUserData() {
      localStorage.setItem(`userData_${userData.username}`, JSON.stringify(userData));
    }

    function loadUserData(username) {
      const saved = localStorage.getItem(`userData_${username}`);
      if (saved) {
        userData = JSON.parse(saved);

        if (typeof userData.portfolio !== 'object' || userData.portfolio === null) {
          userData.portfolio = {};
        } else {
          for (const crypto in userData.portfolio) {
            if (!Array.isArray(userData.portfolio[crypto])) {
              console.warn(`Resetting portfolio for ${crypto} as it's not an array.`);
              userData.portfolio[crypto] = [];
            }
          }
        }
        updateBalanceDisplay();
        updatePortfolioDisplay();
        if (userData.millionDollarModeUnlocked) {
          document.getElementById('millionDollarResetLogin').style.display = 'inline-block';
          document.getElementById('millionDollarReset').style.display = 'inline-block';
        } else {
          document.getElementById('millionDollarResetLogin').style.display = 'none';
          document.getElementById('millionDollarReset').style.display = 'none';
        }
        document.getElementById('loginArea').style.display = 'none';
        document.getElementById('mainContent').style.display = 'block';

        if (userData.gameEndTime) {
          gameEndTime = userData.gameEndTime;
          timeLeft = Math.max(0, Math.floor((gameEndTime - Date.now()) / 1000));
          if (timeLeft > 0) {
            startTimer(Math.ceil(timeLeft / (24 * 60 * 60 * 7))); // Convert seconds back to weeks
          } else {
            document.getElementById('gameTimer').innerText = "Time's Up!";
            if (userData.balance < 1000000) {
              document.getElementById('loseMessage').style.display = 'block';
            }
          }
        }
      } else {
        userData = {
          username: null,
          balance: 1000,
          portfolio: {},
          transactions: [],
          millionDollarModeUnlocked: false,
          gameEndTime: null,
          characterCreationTime: null
        };
      }
    }

    function startNewGame(startingBalance, weeksToMillion) {
      const username = document.getElementById('usernameInput').value;

      if (username) {
        userData.username = username;
        userData.balance = startingBalance;
        userData.portfolio = {};
        userData.transactions = [];
        userData.gameEndTime = null;
        userData.characterCreationTime = Date.now(); // Set character creation time
        saveUserData();
        loadUserData(username);
        updateBalanceDisplay();
        updatePortfolioDisplay();
        startTimer(weeksToMillion);

        document.getElementById('loginArea').style.display = 'none';
        document.getElementById('mainContent').style.display = 'block';
        document.getElementById('winMessage').style.display = 'none';
        document.getElementById('loseMessage').style.display = 'none';
        localStorage.setItem('lastUsername', username);

        alert(`Starting new game as ${username} with $${startingBalance.toLocaleString()} balance.`);

      } else {
        alert('Please enter a username');
      }
    }

    function loginUser() {
      const username = document.getElementById('loginUsernameInput').value;
      if (username) {
        loadUserData(username);
        if (userData.username) {
          localStorage.setItem('lastUsername', username);
          alert(`Welcome back, ${username}!`);
        } else {
          alert(`No saved game found for username: ${username}. Please start a new game.`);
          return;
        }
        updateBalanceDisplay();
        updatePortfolioDisplay();

        document.getElementById('loginArea').style.display = 'none';
        document.getElementById('mainContent').style.display = 'block';
        document.getElementById('winMessage').style.display = 'none';
        document.getElementById('loseMessage').style.display = 'none';

      } else {
        alert('Please enter a username to login');
      }
    }

    function showLoginForm() {
      document.getElementById('loginForm').classList.add('active');
      document.getElementById('newGameForm').classList.remove('active');
    }

    function showNewGameForm() {
      document.getElementById('newGameForm').classList.add('active');
      document.getElementById('loginForm').classList.remove('active');
    }

    function showInstructionsModal() {
      document.getElementById('instructionsModal').style.display = 'block';
      document.getElementById('modalBackdrop').style.display = 'block'; // Use existing backdrop
    }

    function closeInstructionsModal() {
      document.getElementById('instructionsModal').style.display = 'none';
      document.getElementById('modalBackdrop').style.display = 'none'; // Use existing backdrop
    }

    function calculateRSI(prices, periods = 14) {
      if (prices.length < periods) return 50;

      let gains = 0;
      let losses = 0;

      for (let i = 1; i < periods; i++) {
        const difference = prices[i] - prices[i - 1];
        if (difference >= 0) {
          gains += difference;
        } else {
          losses -= difference;
        }
      }

      const avgGain = gains / periods;
      const avgLoss = losses / periods;
      const rs = avgGain / avgLoss;
      return 100 - (100 / (1 + rs));
    }

    function calculateFibonacciLevels(high, low) {
      const diff = high - low;
      const levels = {
        '23.6%': high - (diff * 0.236),
        '38.2%': high - (diff * 0.382),
        '50.0%': high - (diff * 0.5),
        '61.8%': high - (diff * 0.618),
        '78.6%': high - (diff * 0.786)
      };

      const currentPrice = high - diff;
      const fibStrength = Object.entries(levels).reduce((acc, [level, price]) => {
        const deviation = Math.abs(currentPrice - price) / price;
        if (deviation < 0.02) {
          return acc + 1;
        }
        return acc;
      }, 0);

      return {
        levels,
        strength: fibStrength,
        text: Object.entries(levels)
          .map(([key, value]) => `${key}: $${value.toFixed(2)}`)
          .join(', ')
      };
    }

    function calculateGannTrend(prices) {
      if (prices.length < 2) return { trend: 'N/A', strength: 0 };

      const latestPrice = prices[0];
      const previousPrice = prices[1];

      const gannAngles = [45, 90, 135, 180, 225, 270, 315, 360];
      const priceAngles = gannAngles.map(angle => {
        const radians = (angle * Math.PI) / 180;
        return latestPrice * (1 + Math.sin(radians));
      });

      let nearAngles = 0;
      priceAngles.forEach(anglePrice => {
        if (Math.abs(latestPrice - anglePrice) / latestPrice < 0.03) {
          nearAngles++;
        }
      });

      const trend = latestPrice > previousPrice ? 'Up' : 'Down';

      return {
        trend,
        strength: nearAngles,
        angles: priceAngles.map(p => p.toFixed(2)),
        text: `${trend} (Near ${nearAngles} Gann angles)`
      };
    }

    function determineTradingSignal(currentPrice, historicalData, fibData, gannData) {
      const rsi = calculateRSI(historicalData.prices);
      const volume = historicalData.prices.length > 1 ?
        (historicalData.prices[0] - historicalData.prices[1]) : 0;

      let signalStrength = 0;
      let signals = [];

      if (fibData.strength >= 1 && currentPrice > Object.values(fibData.levels)[2]) signalStrength += 1;
      if (gannData.strength >= 1 && gannData.trend === 'Up') signalStrength += 1;
      if (rsi < 30) {
        signalStrength += 1;
        signals.push("Oversold (RSI)");
      }
      if (volume > 0) {
        signalStrength += 1;
        signals.push("Volume increasing");
      }

      if (fibData.strength >= 1 && currentPrice < Object.values(fibData.levels)[3]) signalStrength -= 1;
      if (gannData.strength >= 1 && gannData.trend === 'Down') signalStrength -= 1;
      if (rsi > 70) {
        signalStrength -= 1;
        signals.push("Overbought (RSI)");
      }
      if (volume < 0) {
        signalStrength -= 1;
        signals.push("Volume decreasing");
      }

      let signal, className;
      if (signalStrength >= 3) {
        signal = 'STRONG BUY';
        className = 'buy-signal';
      } else if (signalStrength >= 1) {
        signal = 'BUY';
        className = 'buy-signal';
      } else if (signalStrength <= -3) {
        signal = 'STRONG SELL';
        className = 'sell-signal';
      } else if (signalStrength <= -1) {
        signal = 'SELL';
        className = 'sell-signal';
      } else {
        signal = 'HOLD';
        className = '';
      }

      return {
        signal,
        className,
        strength: Math.abs(signalStrength),
        details: signals.join(', ')
      };
    }

    async function waitForApiDelay() {
      const now = Date.now();
      const timeSinceLastCall = now - lastApiCallTime;
      if (timeSinceLastCall < API_DELAY) {
        await new Promise(resolve => setTimeout(resolve, API_DELAY - timeSinceLastCall));
      }
      lastApiCallTime = Date.now();
    }

    async function fetchHistoricalData(cryptoId) {
      if (historicalCache[cryptoId] &&
        Date.now() - historicalCache[cryptoId].timestamp < CACHE_DURATION) {
        return historicalCache[cryptoId].data;
      }

      await waitForApiDelay();
      try {
        const response = await fetch(
          `https://api.coingecko.com/api/v3/coins/${cryptoId}/market_chart?vs_currency=usd&days=30`
        );
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        const prices = data.prices.map(p => p[1]);

        historicalCache[cryptoId] = {
          data: {
            prices: prices,
            high: Math.max(...prices),
            low: Math.min(...prices)
          },
          timestamp: Date.now()
        };

        return historicalCache[cryptoId].data;
      } catch (error) {
        console.error(`Error fetching historical data for ${cryptoId}:`, error);
        return historicalCache[cryptoId]?.data || {
          prices: [],
          high: 0,
          low: 0
        };
      }
    }

    async function fetchTop100CryptoIds() {
      await waitForApiDelay();
      try {
        const response = await fetch(
          'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&sparkline=false'
        );
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return data.map(item => item.id);
      } catch (error) {
        console.error('Error fetching top 100 crypto IDs:', error);
        return [];
      }
    }

    async function fetchCryptoData() {
      const table = document.querySelector("#cryptoTable tbody");
      const statusMessage = document.getElementById('statusMessage');
      table.innerHTML = "<tr><td colspan='8' class='loading'>Loading data...</td></tr>";
      statusMessage.textContent = "Fetching cryptocurrency list...";

      const cryptoIds = await fetchTop100CryptoIds();
      if (!cryptoIds.length) {
        table.innerHTML = "<tr><td colspan='8'>Error loading cryptocurrency list</td></tr>";
        statusMessage.textContent = "";
        return;
      }

      table.innerHTML = "";
      statusMessage.textContent = `Loading data for ${cryptoIds.length} cryptocurrencies...`;

      for (let i = 0; i < cryptoIds.length; i += BATCH_SIZE) {
        const batch = cryptoIds.slice(i, i + BATCH_SIZE);
        statusMessage.textContent = `Loading data for cryptocurrencies ${i + 1} to ${Math.min(i + BATCH_SIZE, cryptoIds.length)} of ${cryptoIds.length}...`;

        let retryCount = 0;
        const maxRetries = 3;

        while (retryCount < maxRetries) {
          try {
            await waitForApiDelay();
            const url = `https://api.coingecko.com/api/v3/simple/price?ids=${batch.join(',')}&vs_currencies=usd&include_24hr_change=true&include_market_cap=true`;

            const priceResponse = await fetch(url);
            if (!priceResponse.ok) {
              throw new Error(`HTTP error! status: ${priceResponse.status}`);
            }
            const priceData = await priceResponse.json();
            priceCache = {
              data: { ...priceCache.data, ...priceData },
              timestamp: Date.now()
            };

            for (const crypto of batch) {
              if (!priceData[crypto]) continue;

              const price = priceData[crypto].usd;
              const change = priceData[crypto].usd_24h_change;
              const marketCap = priceData[crypto].usd_market_cap;
              const changeClass = change > 0 ? "price-up" : "price-down";

              let historicalData;
              try {
                historicalData = await fetchHistoricalData(crypto);
              } catch (error) {
                console.warn(`Error fetching historical data for ${crypto}, using default values`);
                historicalData = { prices: [], high: price, low: price };
              }

              const fibData = calculateFibonacciLevels(
                historicalData.high,
                historicalData.low
              );
              const gannData = calculateGannTrend(historicalData.prices);
              const tradingSignal = determineTradingSignal(
                price,
                historicalData,
                fibData,
                gannData
              );

              const row = document.createElement("tr");
              row.innerHTML = `
                                <td>${crypto.toUpperCase()}</td>
                                <td>$${price.toFixed(2)}</td>
                                <td class="${changeClass}">${change.toFixed(2)}%</td>
                                <td>
                                    <div class="${tradingSignal.className}">${tradingSignal.signal}</div>
                                    <div class="signal-details">${tradingSignal.details}</div>
                                    <div class="technical-details">
                                        <span class="indicator ${tradingSignal.strength >= 2 ? 'indicator-strong' : 'indicator-weak'}"></span>
                                        Strength: ${tradingSignal.strength}
                                    </div>
                                </td>
                                <td>
                                    <div>${gannData.text}</div>
                                    <div class="technical-details">
                                        Angles: ${gannData.angles.slice(0, 3).join(', ')}...
                                    </div>
                                </td>
                                <td>
                                    <div>Key Levels:</div>
                                    <div class="technical-details">
                                        23.6%: $${fibData.levels['23.6%'].toFixed(2)}<br>
                                        38.2%: $${fibData.levels['38.2%'].toFixed(2)}<br>
                                        50.0%: $${fibData.levels['50.0%'].toFixed(2)}<br>
                                        61.8%: $${fibData.levels['61.8%'].toFixed(2)}<br>
                                        78.6%: $${fibData.levels['78.6%'].toFixed(2)}
                                    </div>
                                </td>
                                <td>$${(marketCap / 1e9).toFixed(2)}B</td>
                                <td>
                                    <div class="trade-buttons">
                                        <button class="trade-button buy-button"
                                                onclick="showTradeModal('${crypto.toUpperCase()}', ${price}, true)">
                                            Buy
                                        </button>
                                    </div>
                                </td>
                            `;
              table.appendChild(row);
            }
            break;
          } catch (error) {
            retryCount++;
            console.warn(`Attempt ${retryCount} failed for batch ${i / BATCH_SIZE + 1}:`, error);
            if (retryCount === maxRetries) {
              console.error(`Failed to load batch ${i / BATCH_SIZE + 1} after ${maxRetries} attempts`);
              const row = document.createElement("tr");
              row.innerHTML = `<td colspan='8'>Error loading data for batch ${i / BATCH_SIZE + 1}. Please try again later.</td>`;
              table.appendChild(row);
            } else {
              await new Promise(resolve => setTimeout(resolve, 5000 * retryCount));
            }
          }
        }
      }

      statusMessage.textContent = "Data loading complete";
    }

    function updateBalanceDisplay() {
      document.getElementById('userBalance').innerText = `Balance: $${userData.balance.toFixed(2)}`;
      localStorage.setItem('balance', userData.balance.toFixed(2));
    }

    function updateRealTime() {
      const now = new Date();
      const dateTimeString = now.toLocaleString();
      document.getElementById('realTime').textContent = dateTimeString;
    }

    window.onload = function () {
      const lastUsername = localStorage.getItem('lastUsername');
      if (lastUsername) {
        document.getElementById('loginForm').classList.add('active');
        document.getElementById('newGameForm').classList.remove('active');
        document.getElementById('loginUsernameInput').value = lastUsername;
      } else {
        document.getElementById('newGameForm').classList.add('active');
        document.getElementById('loginForm').classList.remove('active');
      }
      document.getElementById('mainContent').style.display = 'none';
      document.getElementById('loginArea').style.display = 'block';
      updateRealTime();
      setInterval(updateRealTime, 1000); // Update time every second
    };
  </script>
</body>

</html>
